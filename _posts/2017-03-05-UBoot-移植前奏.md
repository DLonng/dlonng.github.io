---
layout:     post
title:      "UBoot-移植前奏"
subtitle:   "ARM S5PV210 UBoot"
date:       2017-03-05 20:00:00
author:     "陈登龙"
header-img: "img/post-bg-uboot.jpg"
catalog: true
tags:
    - UBoot
---

# UBoot-移植前奏

**一，UBoot版本选择**

在学习阶段移植UBoot，建议选择一个简单的UBoot版本，不是越新的版本越好。
在[这个网站][1]下载UBoot， 这里选择**2012.10**版本。

**二，UBoot编译**

笔者使用的是三星的**S5PV210**开发板，在2012.10这个版本中没有完全实现这个开发板对应的UBoot代码，需要我们手动移植，我们使用的是**s5p_goni_config**的配置。

编译环境：**Ubuntu**, 建议使用**root**进行编译，防止出现意外错误。

**1.解压UBoot**

``` 
tar -xjvf u-boot-2012.10.tar.bz2
```
解压后进入u-boot-2012.10目录。

**2.配置UBoot**

``` 
make s5p_goni_config
```
配置成功会出现提示信息。

**3.编译UBoot**

``` 
make
```
完成之后，会生成2个主要的文件：

``` 
#含有许多的原有调试信息，不能直接在开发板上运行，调试UBoot使用这个文件
u-boot
```

``` 
#将u-boot文件中的多余信息去掉，可以直接在开发板上运行
u-boot.bin
```

编译成功，但是生成的u-boot.bin并不适用我们的开发板，我们需要一步一步的进行移植。
虽然现在不适用，但是我们可以让这个UBoot运行出效果，我们下面在UBoot运行时**点亮S5PV210的一个LED灯**。

UBoot在运行时，首先运行的是：**.../start.S**

我们使用的是**Cortex-A8**芯片，所以进入这个目录：

``` 
cd arch/arm/cpu/armv7
```

编辑start.S:

``` 
vim start.S
```

在**最后的两个#endif**前加上这两个段：

``` 
#用来初始化开发板的LED的GPIO
gpio_init: 
	ldr r11, =0xE0200280
	ldr r12, =0x00001111
	str r12, [r11]

	ldr r11, =0xE0200284
	ldr r12, =0xF
	str r12, [r11]
	mov pc, lr
	
#用来点亮LED
led_on:
	ldr r11, =0xE0200284
	ldr r12, [r11]
	bic r12, r12, #1
	str r12, [r11]
	mov pc, lr
```

原理在ARM裸机阶段已经介绍了，这里就略过了，如果你已经开始学习UBoot了，你应该可以看的懂。


调用这2个段：

在初始化cp15之前调用它。
``` 	
	...
	bl gpio_init
	bl led_on

	/* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl	cpu_init_cp15
	bl	cpu_init_crit
	...
```


重新make后，为了烧写到SD卡后开发板能够运行，我们需要处理下u-boot.bin，**只取出它的前16K代码**，原因后面解释，使用下面的工具：

``` 
# mkv210_image.c 是开发板自带的工具
gcc mkv210_image.c -o mkv210
```

然后使用下面的命令烧写到SD卡中：

``` 
./mkv210 u-boot.bin u-boot.16k
sudo dd iflag=dsync oflag=dsync if=u-boot.16k of=/dev/sdv seek=1
```
插入SD卡，从SD卡启动，即可看到LED被点亮，证明我们的u-boot.16k是成功运行的。


**三，S5PV210的启动原理**

这是手册提供的启动序列：
![BootSeq][2]


虽然三星规定了S5PV210的启动方式，但是UBoot的作者觉得麻烦，就使用下面的方式：
UBoot作者**跳过**了三星为210设置**BL2**阶段，直接在BL1阶段在IRAM运行**uboot-spl.bin**，之后将210K的Uboot.bin加载到SDRAM中，最后载入OS。

**uboot-spl (Second Programmer Loader)**：就是u-boot.16K，因为这个文件最大只有16K。

也就是说UBoot实体分为两部分：
**uboot-spl.bin(16K) + u-boot.bin**

![UBoot][3]



**四，UBoot的调试**

**1.objdump**

``` 
arm-linux-objdump -S[显示源代码和反汇编代码] u-boot | less
```

输出如下格式的文档：
这里介绍一个PC指针跳转的小技巧，根据**偏移**跳转

``` 
	#汇编代码
	_start: b       reset
	#内存地址        机器指令	机器指令对应的汇编指令	
	34800000:       ea000014        b       34800058 <reset>

		ldr     pc, _undefined_instruction
	#ARM汇编是4B，如果单纯的将_undefined_instruction的4B大小的地址放在这里，则指令存储不了，
	#所以这里就存储_undefined_instruction地址减去当前pc地址的偏移:#20。
	#由于ARM运行过程中CPU的3级流水线作用(取指令 -> 译码 -> 执行)
	#所以PC指针并不会指向当前运行的指令，而是指向 当前指令 + 2 那条指令， 
	#如果是32位的CPU， 那么当前的PC指针的指向应该是当前的PC指令地址加上 2 * 4 = 8个字节处的地址。
	#如下：
	#1.当前PC = 0x34800004
	#2.需要增加的2个地址偏移：2 * 4(1个ARM汇编 = 4B) = 8B
	#3._undefined_instruction地址的偏移，这个偏移是由汇编器优化计算的：立即数#20 = 0x14
	#所以 ldr     pc, _undefined_instruction 这条指令执行后：PC = 0x34800004 + 0x8 + 0x14 = 0x34800020

	34800004:       e59ff014        ldr     pc, [pc, #20]   ; 34800020 <_undefined_instruction> 
	
	...
	
	#PC = 0x34800004 + 0x8 + 0x14 = 0x34800020，跳转到这里执行
	34800020 <_undefined_instruction>:
	...
```

**2.hexdump**

```  
	hexdump -C[同时显示二进制和ASCII] u-boot.16K | less
```

输出如下格式文档：
``` 
00000000  53 35 50 43 31 31 30 20  bf 0c 1b 00 45 52 20 20  |S5PC110 ....ER  |
00000010  14 00 00 ea 14 f0 9f e5  14 f0 9f e5 14 f0 9f e5  |................|
00000020  14 f0 9f e5 14 f0 9f e5  14 f0 9f e5 14 f0 9f e5  |................|
00000030  00 02 80 34 60 02 80 34  c0 02 80 34 20 03 80 34  |...4`..4...4 ..4|
```
S5PC110是在**mkv210_image.c**中写入的：
这是官网提供的源码，写的还不错，可以好好研究下。
``` c
/* 
 * 在BL0阶段，iROM内固化的代码读取nandflash或SD卡前16K的内容，
 * 并比对前16字节中的校验和是否正确，正确则继续，错误则停止。
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define BUFSIZE                 (16*1024)
#define IMG_SIZE                (16*1024)
#define SPL_HEADER_SIZE         16
#define SPL_HEADER              "S5PC110 HEADER  "

int main (int argc, char *argv[])
{
	FILE		*fp;
	char		*Buf, *a;
	int		BufLen;
	int		nbytes, fileLen;
	unsigned int	checksum, count;
	int		i;
	
	// 1. 3个参数
	if (argc != 3)
	{
		printf("Usage: mkbl1 <source file> <destination file>\n");
		return -1;
	}

	// 2. 分配16K的buffer
	BufLen = BUFSIZE;
	Buf = (char *)malloc(BufLen);
	if (!Buf)
	{
		printf("Alloc buffer failed!\n");
		return -1;
	}

	memset(Buf, 0x00, BufLen);

	// 3. 读源bin到buffer
	// 3.1 打开源bin
	fp = fopen(argv[1], "rb");
	if( fp == NULL)
	{
		printf("source file open error\n");
		free(Buf);
		return -1;
	}
	// 3.2 获取源bin长度
	fseek(fp, 0L, SEEK_END);
	fileLen = ftell(fp);
	fseek(fp, 0L, SEEK_SET);
	// 3.3 源bin长度不得超过16K-16byte
	count = (fileLen < (IMG_SIZE - SPL_HEADER_SIZE))
		? fileLen : (IMG_SIZE - SPL_HEADER_SIZE);
	// 3.4 buffer[0~15]存放"S5PC110 HEADER  "
	memcpy(&Buf[0], SPL_HEADER, SPL_HEADER_SIZE);
	// 3.5 读源bin到buffer[16]
	nbytes = fread(Buf + SPL_HEADER_SIZE, 1, count, fp);
	if ( nbytes != count )
	{
		printf("source file read error\n");
		free(Buf);
		fclose(fp);
		return -1;
	}
	fclose(fp);

	// 4. 计算校验和
 	// 4.1 从第16byte开始统计buffer中共有几个1
	a = Buf + SPL_HEADER_SIZE;
	for(i = 0, checksum = 0; i < IMG_SIZE - SPL_HEADER_SIZE; i++)
		checksum += (0x000000FF) & *a++;
	// 4.2 将校验和保存在buffer[8~15]
	a = Buf + 8;
	*( (unsigned int *)a ) = checksum;

	// 5. 拷贝buffer中的内容到目的bin
	// 5.1 打开目的bin
	fp = fopen(argv[2], "wb");
	if (fp == NULL)
	{
		printf("destination file open error\n");
		free(Buf);
		return -1;
	}
	// 5.2 将16k的buffer拷贝到目的bin中
	a = Buf;
	nbytes	= fwrite( a, 1, BufLen, fp);
	if ( nbytes != BufLen )
	{
		printf("destination file write error\n");
		free(Buf);
		fclose(fp);
		return -1;
	}

	free(Buf);
	fclose(fp);

	return 0;
}
```

**五，总结**

这是移植UBoot的开始阶段，我们需要熟悉自己的开发板的启动方式，并且能够点亮一个LED来测试我们是否成功编译了UBoot, 这是我们跨出的第一步。


  [1]: ftp://ftp.denx.de/pub/u-boot/
  [2]: https://cheng-zhi.github.io/img/UBoot/post-2017-03-05-BootSeq.png
  [3]: https://cheng-zhi.github.io/img/UBoot/post-2017-03-05-UBoot.png