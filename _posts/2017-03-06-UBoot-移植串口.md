---
layout:     post
title:      "UBoot-移植串口"
subtitle:   "UART S5PV210 UBoot"
date:       2017-03-06 20:00:00
author:     "陈登龙"
header-img: "img/post-bg-uboot.jpg"
catalog: true
tags:
    - UBoot
---

 # UBoot-移植串口
 
 **一，为何需要移植UBoot的UART？**
 
 在系统刚上电的阶段，进行调试的比较好的方法就是使用串口了，所以我们需要为UBoot初始化我们开发板的串口，然后提供相应的调试功能。
 
 
 **二，UART移植**
 
 UART的概念在裸机阶段已经介绍了，这里就不介绍了。
 我们打开 **board/samsung/goni/lowlevel_init.S**：
 
在在最后的**200标号前面加**上这个地方加上**初始化串口**的代码：
这段代码是在**uart_asm_init**这个段中，这个段已经被调用过了，所以我们直接初始化，不用再次调用

``` 
468		...
469     ldr r0, =0xE2900000
470     ldr r1, =0x3
471     str r1, [r0]                @ULCON0 = 0x3
472 
473     ldr r1, =0x305
474     str r1, [r0, #0x4]          @UCON0 = 0x305
475 
476     ldr r1, =0x1
477     str r1, [r0, #0x8]          @UFCON0 = 0x1
478 
479     ldr r1, =0
480     str r1, [r0, #0xC]          @UMCON0 = 0x0
481 
482     ldr r1, =34
483     str r1, [r0, #0x28]         @UBRDIV0 = 34
484 
485     ldr r1, =0xDFDD
486     str r1, [r0, #0x2C]         @UDIVSLOT0 = 13`1
487 
488     ldr r0, =0xE2900020
489     ldr r1, =0x55               @UTH0 = 'U'
490     str r1, [r0]
491 
492     ldr r1, =0x61               @UTH0 = 'a'
493     str r1, [r0]
494 
495     ldr r1, =0x72               @UTH0 = 'r'
496     str r1, [r0]
497 
498     ldr r1, =0x74               @UTH0 = 't'
499     str r1, [r0]
500 
501     ldr r1, =0x5F               @UTH0 = '_'
502     str r1, [r0]
503 
504     ldr r1, =0x4F               @UTH0 = 'O'
505     str r1, [r0]
506 
507     ldr r1, =0x4B               @UTH0 = 'K'
508     str r1, [r0]
509 
510     ldr r1, =0xA                @UTH0 = '\r'
511     str r1, [r0]
512 
513     ldr r1, =0xD                @UTH0 = '\n'
514     str r1, [r0]

515 
516 200:
517     mov pc, lr
```

配置方法，参考数据手册的寄存器配置，这段代码的功能是：**初始化串口，然后在串口打印出Uart-OK，然后换行**。
 
编写完成后，我们需要更改下顶层的Makefile：
将359行的代码的顺序改为360行的顺序。

``` makefile
359 #__LIBS := $(subst $(obj),,$(LIBS)) $(subst $(obj),,$(LIBBOARD))
360 __LIBS := $(subst $(obj),,$(LIBBOARD)) $(subst $(obj),,$(LIBS))

```
**为何这样改呢？**

因为goni/ * 下面的文件最后会被链接成为goni.o
但是359行规定了board的lib链接在u-boot的可执行文件的最后面，但是在制作u-boot.16k的时候，只是取得u-boot的前16K代码，所以Uart初始化的代码没有被执行，程序跑飞。
为了能够执行到UART的初始化代码，我们需要手动将board编译后的目标文件链接到u-boot可执行文件的前面，也就是包含在前16K代码中。

更改后重新make，然后烧写到SD卡，即可看到串口中打印出**Uart-OK!并换行**。

下面我们为已经移植的串口增加一个显示指定的**32Bit地址**中的**16进制**数据的功能

地址通过**r0寄存器传递进子过程**
``` 
display_addr_data:

	@将r0地址中的数据取出来放在r0中
	ldr	r0, [r0]
	@r1对应得地址是串口的寄存器，我们向这个地址写入数据，就会显示在串口终端上
	ldr	r1, =0xE2900020

	@输出一个0
	ldr r2, =0x30				@UTH0 = '0'
	str r2, [r1]
	@输出一个小写的x
	ldr r2, =0x78				@UTH0 = 'x'
	str	r2, [r1]
	@我们需要将数据循环向右移位，每次取出最高的4位输出到串口上，这里给计数器赋初值28
	@因为最高的4位要向右移动28位，之后我们每次将计数器减去4，就可以依次取出所有的位。
	ldr r3, =28

dis_loop_cnt:
	@将要显示的数据右移28位，并将结果放到r2中
	lsr r2, r0, r3
	@将r2的内容与0xFF相与，结果放到r2中
	and r2, r2, #0xF
	@将r2的内容与10(0xA)进行比较，判断是输出数字还是英文字符
	cmp r2, #10
	@如果r2小于10，就加上0x30('0'), 0 + 0x30 = '0'
	addmi r2, r2, #0x30
	@如果r2大于等于10，就加上0x37('A'), 10 + 0x37 = 'A'
	addpl r2, r2, #0x37
	@将r2写入r1,即输出该字符到串口上
	str r2, [r1]

	@将r3计数器减去4,下一次向右移动24位，取出结果放到r3中
	sub r3, r3, #4
	@判断r3是否小于0，当最低位打印过后，r3 = 0 - 4 = -4, 这个条件就不会成立，就会跳到后面换行。
	cmp r3, #0
	@如果r3大于0,继续循环dis_loop_cnt
	bpl dis_loop_cnt

	@如果r3小于0,就换行结束
	ldr r2, =0xA				@UTH0 = '\r'
	str r2, [r1]

	ldr r2, =0xD				@UTH0 = '\n'
	str r2, [r1]

	mov pc, lr
```

我们在这里添加测试代码：

``` 
          @ S5PV210的产品ID在0xE0000000地址中存储，我们把它打印出来 
		  @参数用r0寄存器传递
218     ldr r0, =0xE0000000
219     bl display_addr_data
```


然后进行make，测试可以发现，串口能够打印出S5PV210的产品ID：0x43110220.

串口是调试的利器，我们最好最先初始化UBoot的串口，不然打印不出调试信息。
