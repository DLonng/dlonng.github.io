---
layout:     post
title:      "UBoot-移植DDR"
subtitle:   "DDR S5PV210 UBoot"
date:       2017-03-07 15:00:00
author:     "陈登龙"
header-img: "img/post-bg-uboot.jpg"
catalog: true
tags:
    - UBoot
---


**一，为何需要移植DDR内存？**

因为我们的UBoot分为2个阶段，BL1阶段会将BL2阶段的代码拷贝到DDR内存中运行，所以我们的BL1阶段的代码就需要完成DDR内存的初始化工作，为后的代码搬移做准备。
这次就介绍下S5PV210的DDR内存的初始化的大致方法。

**二，S5PV210的DDR内存**

关于S5PV210的内存原理图分析，参考[这篇文章][1]

**1.初始化要做的工作**

我们需要有**开发板的数据手册**，对应**DDR内存型号的数据手册**和**DDR2 操作时序规范**，这3本手册，最后一本在网上可以下载，前面2本是开发板附带的。在开发板的数据手册中，找到介绍DDR内存的章节，里面详细介绍了DDR内存的初始化步骤，应该是有很多的步骤。

在初始化之前，你需要学习DDR内存的相关基本知识，学习起来需要一定的时间，建议使用**视频学习**，本来初始化DDR内存就非常麻烦，我认为最好的方法就是找一个具体的项目来驱动你去初始化DDR，这样效果会很好。

你在学习了一些DDR内存的基本概念之后，就可以对照开发板的数据手册中寄存器的定义，列出一张表格，分析每个位应该填入什么值，想下面这样：
![RegTable][2]
填写完后，将这个值转换成16进制格式，然后使用汇编语言写入指定的DDR初始化的寄存器中就可以了。

这非常的耗费时间和精力，不过这是必须完成的任务，在你成功初始化后，再回头复习就会有成就感了。

下面是我学习过程中写的一段初始化代码，可以工作，初始化后会通过串口打印出：DDR-Ok。
这段代码加在串口初始化段的后面，就是**lowlevel_init.S的最后面**。

``` 
.globl ddrmem_init
ddrmem_init:

#define APB_DMC_0_BASE			0xF0000000

#define DMC_CONCONTROL 			0x00
#define DMC_MEMCONTROL 			0x04
#define DMC_MEMCONFIG0 			0x08
#define DMC_MEMCONFIG1 			0x0C
#define DMC_DIRECTCMD 			0x10
#define DMC_PRECHCONFIG 		0x14
#define DMC_PHYCONTROL0 		0x18
#define DMC_PHYCONTROL1 		0x1C
#define DMC_PWRDNCONFIG 		0x28
#define DMC_TIMINGAREF 			0x30
#define DMC_TIMINGROW 			0x34
#define DMC_TIMINGDATA 			0x38
#define DMC_TIMINGPOWER 		0x3C
#define DMC_PHYSTATUS 			0x40

	ldr r0, =APB_DMC_0_BASE
	
	//step 2: Set the PhyControl0.ctrl_start_point, .ctrl_inc, .ctrl_dll_on
	ldr r1, =0x0010100A
	str r1, [r0, #DMC_PHYCONTROL0]

	//step 3: Set the PhyControl1.ctrl_shiftc, .ctrl_offsetc
	ldr r1, =0x00000086
	str r1, [r0, #DMC_PHYCONTROL1]

	//step 4: PhyControl0 DLL start
	ldr r1, =0x0010100B
	str r1, [r0, #DMC_PHYCONTROL0]

find_lock_val:
	//step 11: Loop until DLL is locked
	ldr r1, [r0, #DMC_PHYSTATUS]
	and r2, r1, #0x7
	cmp r2, #0x7
	bne find_lock_val

	//step 12: Force value locking
	and r1, #0x3FC0
	mov r2, r1, LSL #18
	orr	r2, r2, #0x100000
	orr r2, r2, #0x1000
	orr r1, r2, #0xB
	str r1, [r0, #DMC_PHYCONTROL0]

	//step 5: ConControl auto refresh off
	ldr r1, =0x0FFF1010
	str r1, [r0, #DMC_CONCONTROL]
	
	//step 6: MemControl BL = 4, 1 chip, DDR2 type, dynamic power down off
	ldr r1, =0x00202400
	str r1, [r0, #DMC_MEMCONTROL]

	//step 7: MemConfig0 512MB config, 8 banks, Mapping Method[12:15]0:linkear
	ldr r1, =0x20E00323
	str r1, [r0, #DMC_MEMCONFIG0]

	//step 8-1: PrechConfig
	ldr r1, =0xFF000000
	str r1, [r0, #DMC_PRECHCONFIG]

	//step 8-2: PwrdnConfig
	ldr r1, =0xFFFF00FF
	str r1, [r0, #DMC_PWRDNCONFIG]

	//step 9-1: TimingAref
	ldr r1, =0x0000040E
	str r1, [r0, #DMC_TIMINGAREF]

	//step 9-2: TimingRow
	ldr r1, =0x11122206
	str r1, [r0, #DMC_TIMINGROW]

	//step 9-3: TimingData
	ldr r1, =0x12240000
	str r1, [r0, #DMC_TIMINGDATA]

	//step 9-4: TimingPower
	ldr r1, =0x05DC0343
	str r1, [r0, #DMC_TIMINGPOWER]

	//step 14: DirectCmd chip0 NOP
	ldr r1, =0x07000000
	str r1, [r0, #DMC_DIRECTCMD]

	//step 16: DirectCmd chip0 PALL
	ldr r1, =0x01000000
	str r1, [r0, #DMC_DIRECTCMD]

	//step 17: DirectCmd chip0 EMRS2
	ldr r1, =0x00020000
	str r1, [r0, #DMC_DIRECTCMD]

	//step 18:DirectCmd chip0 EMRS3
	ldr r1, =0x00030000
	str r1, [r0, #DMC_DIRECTCMD]

	//step 19: DirectCmd chip0 EMRS1(MEM DLL on, DQS# disable)
	ldr r1, =0x00010000
	str r1, [r0, #DMC_DIRECTCMD]

	//step 20: DirectCmd chip0 MRS(MEM DLL reset) CL = 4, BL = 4
	ldr r1, =0x00000542
	str r1, [r0, #DMC_DIRECTCMD]

	//step 21: DirectCmd chip0 PALL
	ldr r1, =0x01000000
	str r1, [r0, #DMC_DIRECTCMD]

	//step 22-1: DirectCmd chip0 REFA
	ldr r1, =0x05000000
	str r1, [r0, #DMC_DIRECTCMD]

	//step 22-2: DirectCmd chip0 REFA
	ldr r1, =0x05000000
	str r1, [r0, #DMC_DIRECTCMD]

	//step 23: DirectCmd chip0 MRS(MEM DLL unreset)
	ldr r1, =0x00000442
	str r1, [r0, #DMC_DIRECTCMD]

	//step 25-1:DirectCmd chip0 EMRS1(OCD default)
	ldr r1, =0x00010380
	str r1, [r0, #DMC_DIRECTCMD]

	//step 25-2:DirectCmd chip0 EMRS1(OCD default)
	ldr r1, =0x00010000
	str r1, [r0, #DMC_DIRECTCMD]

	//step 27: ConControl auto refresh on
	ldr r1, =0x0FF01030
	str r1, [r0, #DMC_CONCONTROL]

	//step 28: MemControl, BL = 4, 1 chip DDR2 type, dynamic self refresh, force prechange, dynamic  power down
	ldr r1, =0x00202400
	str r1, [r0, #DMC_MEMCONTROL]

	/* UART : DDR-OK! */
	ldr r0, =0xE2900020

	ldr r1, =0x44
	str r1, [r0] 

	ldr r1, =0x44
	str r1, [r0] 

	ldr r1, =0x52
	str r1, [r0]

	ldr r1, =0x5F
	str r1, [r0]

	ldr r1, =0x4F
	str r1, [r0]

	ldr r1, =0x6B
	str r1, [r0]

	ldr r1, =0x21
	str r1, [r0]

	ldr r1, =0xA
	str r1, [r0]

	ldr r1, =0xD
	str r1, [r0]

	mov pc, lr

```



在串口初始化后面，测试我们的DDR：

``` 
	/* for UART */
	bl	uart_asm_init
	
	/* my ddr mem init */
	bl ddrmem_init

	/* test DDR */
	ldr r0, =0x30000000
	ldr r1, =0x12345678
	/* 将r1的值放到内存地址0x30000000处的内存中 */
	str r1, [r0]
	/* 读取刚才写入的r1的值，如果是0x12345678，则DDR初始化成功 */
	bl display_addr_data
```

重新make，测试可以发现串口会打印DDR-OK。
DDR初始化需要耐心，需要坚持，在初始化成功后，建议修改寄存器的值，多次测试效果，加深印象，后面会写几篇关于DDR的博客。




  [1]: https://cheng-zhi.github.io/2017/02/27/%E5%8E%9F%E7%90%86%E5%9B%BE%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E7%B1%BB%E6%8E%A5%E5%8F%A3/
  [2]: https://cheng-zhi.github.io/img/UBoot/post-2017-03-07-RegTable.png