---
layout:     post
title:      "ARM裸机-系统时钟"
subtitle:   "ARM Tiny210 SystemClock"
date:       2017-02-28 20:00:00
author:     "陈登龙"
header-img: "img/post-bg-unix-linux.jpg"
catalog: true
tags:
    - ARM裸机
---


# ARM裸机-系统时钟


**一，时钟简介**

CPU的时钟可以简单来说就是CPU的心跳，该时钟由一个**晶振**产生。

晶振：利用PLL寄存器将较低的晶振频率转化为CPU的高频率，然后CPU利用分频器降低频率给其他外设。
晶振 -> PLL(锁定时间，PLL寄存器) -> CPU
CPU -> 分频 -> 外设

Tiny210外接的晶振是24MHz。
![PLL][1]

在SOC中，有3种常见的系统时钟，在不同的SOC中，名称可能不同，当时基本原理都差不多。

**FCLK**：CPU专用
**HCLK**：RAM-Like专用，例如，SDRAM，网卡，NOR Flash
**PCLK**：外设专用，例如，串口，系统定时器

**二,Tiny210时钟**

Tiny210 中包含 3 大类时钟,分别是：

主系统时钟(**MSYS**)：用来给 Cortex A8 处理器,dram 控制器,3D,IRAM,IROM,中断控制器等提供时钟;

显示相关的时钟(**DSYS**)：用来给显示相关的部件提供时钟,包括 FIMC, FIMD, JPEG, and multimedia IPs;

外围设备的时钟(**PSYS**)：用来给外围设备提供时钟,如 i2s, spi,i2c,uart 等

如下图所示：
![ClockDomain][2]

Tiny210外接的晶振频率(简称 **Fin**)为 **24MHz**,通过**时钟控制逻辑 PLL** 可以提高系统时钟。Tiny210 共有 4 个**倍频器**,即 **PLL**,包括 **APLL**(供 MSYS 使用),**MPLL**(供 DSYS 使用),**EPLL**(供 PSYS使用),**VPLL**(供 video 相关的时钟使用)。
3 大类时钟domain中,可以使用不同的分频系数,使其给不同部件输出所需要的时钟频率。

这是Tiny210的**时钟树**：
![ClockTree][3]


**三，初始化Tiny210的时钟**

我们编写一个demo来启动Tiny210的时钟。demo包含下面这些文件：
**clock.h,clock.c,main.c,makefile,start.S**

**start.S**

``` 
.global .text
.global _start

_start:
	#关闭看门狗，具体的寄存器地址要看数据手册
	ldr r0, =0xE2700000
	mov r1, #0
	str r1, [r0]

	#因为要调用C函数，所以先要设置栈指针
	ldr sp, =0x40000000

	#调用C语言函数初始化时钟
	bl clock_init

	#调用C语言函数main
	bl main

#使得程序停在这里
loop:
	b loop
```

**clock.h**

``` c

/* 这些寄存器的地址在数据手册中有描述，在这里定义即可 */
#define CLK_SRC0 			(*((volatile unsigned long *)0xE0100200))
#define APLL_LOCK 			(*((volatile unsigned long *)0xE0100000))		
#define MPLL_LOCK 			(*((volatile unsigned long *)0xE0100008))
#define CLK_DIV0 			(*((volatile unsigned long *)0xE0100300))
#define APLL_CON0 			(*((volatile unsigned long *)0xE0100100))
#define MPLL_CON 			(*((volatile unsigned long *)0xE0100108))


/* 与分频相关的配置数值 */
#define APLL_MDIV       	0x7d
#define APLL_PDIV       	0x3
#define APLL_SDIV      	 	0x1
#define MPLL_MDIV		0x29b
#define MPLL_PDIV		0xc
#define MPLL_SDIV		0x1


/* 根据上面的配置数值，来为寄存器配置分频率数值 */
#define set_pll(mdiv, pdiv, sdiv)	((1 << 31) | (mdiv << 16) | (pdiv << 8) | (sdiv << 0))
#define APLL_VAL					set_pll(APLL_MDIV, APLL_PDIV, APLL_SDIV)
#define MPLL_VAL					set_pll(MPLL_MDIV, MPLL_PDIV, MPLL_SDIV)

/* 时钟初始化的声明 */
void clock_init(void);
```

**clock.c**

``` c
/* 包含头文件 */
#include "clock.h"


/*
 * Clock init.
 */
void clock_init(void) {
	/* Don`t use PLL. */
	CLK_SRC0 = 0x0;

	/* Using default lock time. */
	APLL_LOCK = 0x00000FFF;
	MPLL_LOCK = 0x00000FFF;

	/* 根据配置的分频数值，最后得出这个寄存器的配置数值 */
	CLK_DIV0 = 0x14131440;

	/* Set PLL. */
	APLL_CON0 = APLL_VAL;
	MPLL_CON  = MPLL_VAL;	

	/* Open PLL. */
	CLK_SRC0 = 0x10001111;
}
```

**main.c**

``` c
/*
 * 实现点亮LED的功能 
 */
 
 
#define 	GPJ2CON 	(*(volatile unsigned long *) 0xE0200280)
#define 	GPJ2DAT		(*(volatile unsigned long *) 0xE0200284)

#define 	GPJ2_0_OUTPUT 	(1<<(0*4))
#define 	GPJ2_1_OUTPUT 	(1<<(1*4))
#define 	GPJ2_2_OUTPUT 	(1<<(2*4))
#define 	GPJ2_3_OUTPUT 	(1<<(3*4))

void delay(unsigned long count)
{
	volatile unsigned long i = count;
	while (i--);
}

int main(void)
{
	// 设置GPJ2CON0/1/2/3为输出引脚
	GPJ2CON = GPJ2_0_OUTPUT | GPJ2_1_OUTPUT | GPJ2_2_OUTPUT | GPJ2_3_OUTPUT;
	
	while (1)
	{
		// LED on
		GPJ2DAT = 0;			
		delay(0x100000);	
		
		// LED off
		GPJ2DAT = 0xf;			
		delay(0x100000);
	}
	return 0;
}

```

**Makefile**

Makefile与前面的文章中的Makefile基本相同。

``` makefile
clock.bin: start.o main.o clock.o
	arm-linux-ld -Ttext 0x20000000 $^ -o clock.elf 
	arm-linux-objcopy -O binary clock.elf clock.bin
	arm-linux-objdump -D clock.elf > clock_elf.dis

%.o : %.S
	arm-linux-gcc -c $< -o $@ 

%.o : %.c
	arm-linux-gcc -c $< -o $@  

clean:
	rm *.o *.elf *.bin *.dis -f
```

编写完后，make生成clock.bin,下载到开发板上发现**LED闪烁**。
如何证明时钟初始化了呢？我们可以加上宏定义用来关闭PLL

**clock.c**

``` c
/* 包含头文件 */
#include "clock.h"

/* PLL关闭宏 */
#define PLL_OFF 

/*
 * Clock init.
 */
void clock_init(void) {
	/* Don`t use PLL. */
	CLK_SRC0 = 0x0;
	
	/* 我们定义了PLL_OFF，下面的代码就不会编译 */
#ifndef PLL_OFF
	/* Using default lock time. */
	APLL_LOCK = 0x00000FFF;
	MPLL_LOCK = 0x00000FFF;

	/* 根据配置的分频数值，最后得出这个寄存器的配置数值 */
	CLK_DIV0 = 0x14131440;

	/* Set PLL. */
	APLL_CON0 = APLL_VAL;
	MPLL_CON  = MPLL_VAL;	

	/* Open PLL. */
	CLK_SRC0 = 0x10001111;
#endif	
}
```

重新make，下载后可以发现，**LED闪烁的慢了**，说明我们的之前的时钟初始化正确。





  [1]: https://cheng-zhi.github.io/img/post-2017-02-28-PLL.png
  [2]: https://cheng-zhi.github.io/img/post-2017-02-28-ClockDomains.png
  [3]: https://cheng-zhi.github.io/img/post-2017-02-28-ClockTree.png
