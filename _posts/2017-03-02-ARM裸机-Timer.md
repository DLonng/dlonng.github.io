---
layout:     post
title:      "ARM裸机-Timer"
subtitle:   "ARM Tiny210 PWM WatchDog RTC"
date:       2017-03-02 19:00:00
author:     "陈登龙"
header-img: "img/post-bg-unix-linux.jpg"
catalog: true
tags:
    - ARM裸机
---

# ARM裸机-Timer

**一，定时器Timer简介**

什么是定时器？

芯片使用一个 **递减计数器(Down Counter)** 模块，每来一个CLK脉冲，计数器减1，当计数器减到0, 并触发相应的输出引脚，输出信号跳变，产生中断或者其他功能。

如下图：
![Timer][1]

在SOC中一般都有4种常见的定时器：**SysTimer, WatchDog, RTC, PWM**。后面的3种在定时的基本功能上增加了一些自己独有的能力，下面对后面3种进行简单的介绍。


**二，WatchDog**

**1.什么是WatchDog？**

简单来说就是：**带有复位功能的递减计数器**。
看门狗的**作用**在于监控CPU的运行,保证在诸如噪音和系统错误等这样的故障干扰情况下能尽快**复位CPU**正常工作。
**注意**：WatchDog不用与解决软件相关的问题。


**2.S5PV210的WatchDog**

如下图：
![WTD][2]

你需要知道下面的几点：

1.WTD：看门狗使用的是**PCLK**时钟，在寄存器中可以设置分频系数。

2.MUX：一个多路选择器，用竖着梯形表示，数电里面有介绍。

3.WTCNT：**存储递减次数**的寄存器。

4.WTDAT：当WTCNT = 0时，WTDAT中的值**自动加载(Auto Loader)**到WTCNT中。

5.看门狗可以实现中断功能或者是Reset CPU功能，这根据WTCNT的 Bit 2 来配置。


**3.如何防止WTD不断Reset**

WTD在计数器递减到0后，如何配置为Reset CPU，那么CPU就会被Reset，我们在大多数情况下是不需要Reset CPU的，因此我们就需要阻止WTD复位。
WTD只有在WTCNT = 0时，才会输出跳变信号。
所以，我们只需要**feed_watchdog**，称为**喂狗**，就是使用软件的方法，**在WTCNT变为0后再向WTCNT中写入值**。


**三，RTC**

**Real Time Clock (RTC)**， 实时时钟，用来在系统断电时,利用备用的锂电池继续记录时间。
 
 S5PV210 RTC框图：
 ![RTC][3]
 
 这个框图也不复杂，你需要知道下面几点：

1.RTC的外部晶体震荡器HZ：**32.768KHZ = 2^15**。

2.经过分频率后，在RTC内部是1HZ，也就是1S递减一次。

3.控制寄存器可以实现对RTC的直接控制。

S5PV210的RTC模块使用起来非常简单，我们只需要**配置**RTC的控制寄存器，然后从多个数据寄存器中分别**读取**sec，min，hour，mon，year等数据就可以了，不需要像Corext-M3那样需要我们计算时间了。



**四，PWM**

**1.什么是PWM?**

PWM **脉冲宽度调制**, 控制一个周期中高电平的比例(**占空比**)，即控制高电平和低电平的宽度。
PWM就是在普通的Timer中引入一个**比较寄存器**，**通过计数器与比较寄存器比较的结果来决定什么时候进行信号的跳变。**

这是**S5PV210**的PWM框图：
![PWM-Diagram][4]


下面是S5PV210的一个**PWM时序**：
![PWM][5]


可以简单的分析，2 - 4是一个周期，**低电平的宽度是50, 高电平宽度是109**。
在**3**这个位置，**比较寄存器和计数器的值相等，信号就会跳变**，这就是PWM的原理。


下面我们编写一个Demo来产生上面的波形，并驱动峰鸣器，我们使用**预分频器PRESCALER0**和**TCMPB0，TCNTB0**这组寄存器来控制**TOUT_0**(这个复用引脚连接到了峰鸣器)，我们向这个引脚输出PWM给峰鸣器。

用到的文件跟之前的文章差不多，这里只介绍：**main.c, pwm.c, pwm.h**了。

**pwm.h**

``` c
#ifndef PWM_H
#define PWM_H

#include "cpu_io.h"
#include "gpio.h"

/* 根据数据手册中PWM寄存器的定义顺序构造出这个结构体(只定义了第一组) */
struct s5pv210_pwm {
	unsigned int TCFG0;
	unsigned int TCFG1;
	unsigned int TCON;
	unsigned int TCNTB0;
	unsigned int TCMPB0;
	unsigned int TCNTO0;
};

/* PWM寄存器的基地址 */
#define S5PV210_PWM_BASE	0xE2500000

/* Init PWM */
void pwm_init(void);

/* Init beep */
void beep_init(void);

/* Start beep with pwm */
void start_pwm_beep(void);

#endif
```

**pwm.c**

``` c
#include "pwm.h"


/*
 * Init pwm.
 */
void pwm_init(void) {
	struct s5pv210_pwm* pwm_base = (struct s5pv210_pwm*)S5PV210_PWM_BASE;

	/* 配置时钟分频系数，可以适当的配置高些，防止频率过快 */
	__REG(&pwm_base->TCFG0) = 250;
	
	/* 配置MUX的分频 */
	__REG(&pwm_base->TCFG1) = 0x4;

	/* 按照手册上说的配置 */
	__REG(&pwm_base->TCNTB0)  = 50 + 109;
	__REG(&pwm_base->TCMPB0)  = 109;
}


/*
 * Init beep.
 * Config GPD0_0 is TOUT_0 mode(0010 = 0x2).
 */
void beep_init(void) {
	struct s5pv210_gpio* gpio_base = (struct s5pv210_gpio*)S5PV210_GPIO_BASE;

	unsigned int var = 0;
	var = readl(&gpio_base->gpio_d0.con);
	var &= ~(0xF << 0);
	/* 0010 = TOUT_0 */
	var |= (0x2 << 0);
	writel(var, &gpio_base->gpio_d0.con);
}



/*
 * Start beep with PWM.
 */
void start_pwm_beep(void) {	
	struct s5pv210_pwm* pwm_base = (struct s5pv210_pwm*)S5PV210_PWM_BASE;
	/* Start Timer, close update bit*/
	__REG(&pwm_base->TCON) = 0x8;
}


```


**main.c**

```   
#include "pwm.h"
 

int main()
{ 
	/* 先初始化峰鸣器的GPIO */
	beep_init();
	/* 初始化PWM寄存器 */
	pwm_init();
	/* 启动峰鸣器 */
	start_pwm_beep();
	
 	return 0;
}

```

编译之后，下载到RAM中运行，即可发现峰鸣器报警。
**改变PWM的高电平持续时间可以控制音量大小，改变频率控制音调高低。**


PWM的应用：

1.产生周期信号。

2.采样。

3.工控，例如：步进电机的旋转速度。

  [1]: https://cheng-zhi.github.io/img/Timer/post-2017-03-02-Timer.png
  [2]: https://cheng-zhi.github.io/img/Timer/post-2017-03-02-WTD.png
  [3]: https://cheng-zhi.github.io/img/Timer/post-2017-03-02-RTC.png
  [4]: https://cheng-zhi.github.io/img/Timer/post-2017-03-02-PWM-Diagram.png
  [5]: https://cheng-zhi.github.io/img/Timer/post-2017-03-02-PWM.png
