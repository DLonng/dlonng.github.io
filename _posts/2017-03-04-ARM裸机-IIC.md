---
layout:     post
title:      "ARM裸机-IIC"
subtitle:   "ARM Tiny210 IIC"
date:       2017-03-04 15:00:00
author:     "陈登龙"
header-img: "img/post-bg-unix-linux.jpg"
catalog: true
tags:
    - ARM裸机
---

# ARM裸机-IIC

**一，IIC简介**

**I2C(Inter- Integrated Circuit)** 总线是由PHILIPS 公司开发的两线式**串行半双工同步总线**,用于连接微控制器及其外围设备，是微电子通信控制领域广泛采用的一种总线标准。具有接口线少,控制方式简单,器件封装形式小,通信速率较高等优点。

**IIC不是软件定义的协议**，而是**硬件规范**，如果CPU支持IIC控制器，则我们可以直接利用IIC控制器来控制IIC传输数据。在带OS(Linux)的开发中，我们不需要直接控制IIC时序，而是直接使用IIC子系统模块，里面已经集成了IIC控制器。
如果是为了学习，建议大家可以使用**软件**和GPIO口，来**模拟**IIC的时序，并访问IIC芯片。



这次文章的**重点是理解IIC的概念**，在实际的Linux中已经有IIC控制器模块，我们在开发的时候会使用即可，但是IIC的时序原理我们还是有必要了解的，这可以方便我们调试IIC。



**二，IIC总线拓扑结构**

这是IIC的拓扑结构图：
![IIC][1]

I2C 总线在物理连接上非常简单,分别由 **SDA(串行数据线)**和 **SCL(串行时钟线)**及**上拉电阻**组成。通信原理是通过对 SCL 和 SDA 线高低电平时序的控制,来产生 I2C 总线协议所需要的信号进行数据的传递。在**总线空闲**状态时,这两根线一般被上面所接的**上拉电阻拉高**,保持着高电平, 上拉电阻范围 **4.7K~100K**。

IIC和前面的UART比较，IIC是**同步串行半双工通信总线**。

IIC 有**四种工作模式**:

1.主机(**master**)发送

2.主机接收

3.从机(**Slave**)发送

4.从机接收


**三，IIC总线特征**

IIC 总线上的每一个设备都可以作为主设备或者从设备,而且**每一个从设备都会对应一个唯一的地址**(可以从 IIC 器件的数据手册得知)。主从设备之间就通过这个地址来确定与哪个器件进行通信,在通常的应用中,我们把 **CPU** 带 IIC 总线接口的模块作为**主设备**,把**挂接在总线上的其他设备作为从设备**。


**IIC总线能挂接的IIC器件数目：**

I2C 总线上可挂接的设备数量受总线的**最大电容限制**,如果所挂接的是**相同型号**的器件,则还受**器件地址**的限制。

一般IIC设备地址是 **7 位地址**(也有 10 位) ,地址分成**两部分**:

1.**芯片固化地址**(生产芯片时候哪些接地,哪些接电源,已经固定)


2.**可编程地址**(引出 IO 口, 由硬件设备决定) 

如下图：
![IIC-Addr][2]

某一个器件是 7 位地址,其中 **10101 A2 A1 A0 高 4 位出厂时候固定**了,**低 3 位可以由设计者决定**, 则一条 IIC 总线上只能挂该种器件最多 8 个。


**IIC总线速度传输速度:**

I2C 总线数据传输速率在**标准模式下可达 100kbit/s**,**快速模式下可达 400kbit/s**,**高速模式下可达 3.4Mbit/s**。
一般通过 IIC 总线接口可编程时钟来实现传输速率的调整。



**IIC总线数据格式**

这是数据手册上的IIC数据传输格式：
![IIC-DataFormat][3]


**S**：启始信号

**Slave Address 7Bits**：7位的从设备地址

**R/W**：1位读/写标识位

**A**：从设备应答位，用来表示从设备的状态

**DATA**(1Byte)：1Byte的数据

**A**：从设备应答位，用来表示从设备的状态

**P**：停止位

I2C 总线上的主设备与从设备之间以**字节(8 位)**为单位进行**双向**的数据传输。


**四，IIC时序介绍**

**1.IIC总线协议基本时序信号**

**空闲状态**：SCL 和 SDA 都保持着高电平。

**起始信号S**：当 **SCL 为高**电平期间而 **SDA由高到低的跳变**,表示产生一个起始条件。在起始条件产生后,总线处于忙状态,由本次数据传输的主从设备独占,其他 IIC 器件无法访问总线。

**停止信号P**：当 **SCL 为高**而 **SDA 由低到高的跳变**,表示产生一个停止条件。

**应答信号ACK**：每个字节传输完成后的下一个时钟信号,在 **SCL 高**电平期间, **SDA 为低**, 则表示一个应答信号。


**注意：起始和结束信号总是由主设备产生，应答信号由从设备产生。**


**2.IIC启始信号时序图**

如下图：**SCL为高，SDA由高到低跳变**
![IIC-Start][4]

**3.IIC结束信号时序图**

如下图：**SCL为高，SDA由低到高跳变**
![IIC-Pause][5]


**4.IIC数据传输时序图**

如下图：
![IIC-DataTran][6]

SDA线上的数据状态 **仅在SCL为低电平** 的期间才能改变，如果SDA线的数据状态在SCL为高电平期间改变，则会**产生IIC的起始或者结束信号**，导致数据传输失败。

即，数据传递中：

**1.SCL为低电压时，SDA才能发生跳变。**


**2.SCL为高电压时，SDA必须保持。**

何时**取数据**？
在**SCL为低向高跳变**，且**SDA为高**时，从设备可以取数据。


如果你有兴趣，可以编写程序来模拟IIC的时序信号，在GPIO口产生对应的输出波形，经而还可以利用调试好的IIC接口来
访问IIC芯片，例如**AT24CXX**等，这对理解IIC的时序有很大的帮助，笔者就在**Cotrex-M3上模拟过IIC的时序信号**，下面是参考代码：

``` c
#ifndef _IIC_H
#define _IIC_H

#include "stm32f10x.h"
#include "io_bit.h"
#include "delay.h"

// PB10、PB11配置为输出
void iic_init(void);


void iic_start(void);
void iic_stop(void);
u8 iic_write(u8 dat);
u8 iic_read(u8 ack);

#define SDA_WRITE() {GPIOB->CRH &= ~(0x0f<<(3*4));GPIOB->CRH |= 0x03<<(3*4);}
#define SDA_READ() {GPIOB->CRH &= ~(0x0f<<(3*4));GPIOB->CRH |= 0x04<<(3*4);}
#define SCL PBout(10)
#define SDA_W PBout(11)
#define SDA_R PBin(11)

#endif

```




``` c
#include "iic.h"

/*
 * IIC初始化。
 * 配置GPIO为开漏复用输出。
 */
void iic_init(void)
{
	RCC->APB2ENR |= 1<<3; 
	GPIOB->CRH &= ~(0xff<<(2*4));
	GPIOB->CRH |= 0x33<<(2*4);
	GPIOB->ODR |= 3<<10;	
}

/*
 * 模拟IIC的开始信号
 */
void iic_start(void)
{
	SDA_WRITE();
	SCL = 1;
	SDA_W = 1;
	//保持至少4.7us
	delay_us(5);
	SDA_W = 0;
	//SDA拉低保持至少4us
	delay_us(5);
	//在写时序里，SCL要先拉低才能写
	SCL = 0;  
}


/*
 * 模拟IIC的停止信号
 */
void iic_stop(void)
{
	SDA_WRITE();
	//SCL在读写时序后，都会被拉低
	SCL = 0;   
	SDA_W = 0;
	delay_us(5);
	SCL = 1;
	//保持至少4us
	delay_us(5);
	SDA_W = 1;
	delay_us(5);
}

/*
 * 向IIC中写入1B数据
 */
u8 iic_write(u8 dat)
{
	u8 i,ack;
	SDA_WRITE();//SDA初始化为输出
	for(i=0;i<8;i++)
	{
			//取最高位
			SDA_W = dat>>7; 
			//移除最高位
			dat <<=1;     
			delay_us(2);
			//高电平期间写数据
			SCL = 1;       
			//为下次数据做准备
			delay_us(2);
	}
	
	//主设备在第九个时钟释放SDA线，从设备应答会把SDA线拉低
	SDA_READ();    
	delay_us(2);
	//  第九个时钟
	SCL = 1;    
	ack = SDA_R;
	delay_us(2);
	SCL = 0;    
	 //ack为0是应答
	return ack;	  
}


/*
 * 从IIC中读出1B数据
 */
u8 iic_read(u8 ack)
{
	u8 i,dat;
	SDA_READ();
	for(i=0;i<8;i++)
	{
		SCL = 1;
		dat <<= 1;
		if(SDA_R)
		{
			dat |= 0x01; 
		}
		delay_us(2);
		SCL = 0; 
		delay_us(2);
	}

	SDA_WRITE();
	 //第九个时钟, stm32应答
	SDA_W = ack;  
	delay_us(2);
	SCL = 1; 
	delay_us(2);
	SCL = 0;     

	return dat;
}

```

这些代码**全部**都是**参考IIC的时序图**写出来的，其中的延迟时间需要查看IIC的数据手册。









  [1]: https://cheng-zhi.github.io//img/IIC/post-2017-03-04-IIC.png
  [2]: https://cheng-zhi.github.io//img/IIC/post-2017-03-04-IIC-Addr.png
  [3]: https://cheng-zhi.github.io//img/IIC/post-2017-03-04-IIC-DataFormat.png
  [4]: https://cheng-zhi.github.io//img/IIC/post-2017-03-04-IIC-S.png
  [5]: https://cheng-zhi.github.io//img/IIC/post-2017-03-04-IIC-P.png
  [6]: https://cheng-zhi.github.io//img/IIC/post-2017-03-04-IIC-DataTran.png
