---
layout:     post
title:      "原理图分析-内存类接口"
subtitle:   "Tiny210 PCB Memory RAM-Like"
date:       2017-02-27 10:00:00
author:     "陈登龙"
header-img: "img/post-bg-apple-event-2015.jpg"
catalog: true
tags:
    -原理图分析
---



# 原理图分析-内存类接口

**一，内存类接口简介**

内存类接口：**RAM-Like**，是指接口类似与RAM芯片的一些外设，例如网卡，Nor Flash，他们一般都有下面的引脚：**地址线，数据线，CS，RE，WE**。
如下图所示：
![RAM-Like][1]

**二，内存原理图分析**

这是一张Tiny210中内存芯片SDRAM的原理图，Tiny210一共有**4块**这样的芯片：
![Tiny210 Memory][2]
对他的分析如下：
1.总线：含有地址线和数据线。
2.使能引脚：含有片选线，读写使能，时钟引脚，行列地址引脚
3.含有其他的一些附属的电路，对编程没有直接的影响。


**关于CS的2个问题：**

**1.地址线，数据线上有众多的设备，如何避免相互影响？**

CPU的地址线和数据线并联了许多的外设，那莫如何避免相互影响呢？我们知道芯片有个**CS(Chip Select)**片选引脚，之所以叫做片选，可以看出是CPU当前选中这块芯片了。所以CPU为了避免访问冲突，**访问一块芯片之前，先设置该芯片的CS为低电平，其他外设CS为高电平，这样就可以单独访问该芯片了**。


**2.是否需要我们手工设置CS？**

**不需要**，CPU在访问某个地址时，CPU发出地址信号给**内存控制器**，内存控制器根据该地址所在的Bank决定让哪一个片选信号为低电平。
**Bank**：每一个片选引脚对应的地址范围称为一个bank。这个地址访问一般都对应一个外设，例如RAM，网卡，Nor Flash等。访问这个一个外设的Bank，该Bank对应与该外设的CS引脚就被拉低，表示该外设被CPU选中。

下面是内存控制器的模型：
![MemCtl][3]
可以看出CPU将地址发给MemCtl，由MemCtl确定地址的范围对应的Bank，然后将该Bank对应的CS拉低，即可选中对应的芯片。


**如何计算芯片的内存呢？**


可以看出地址线的范围是：Addr0 - Addr13，一共14条地址线。**SDRAM的内存访问是按照行地址和列地址来访问的**，也就是说这14条地址线会根据行地址引脚(**nRAS**)和列地址(**nCAS**)引脚的状态来发送14位的行地址或者14位的列地址，所以**一块SDRAM**芯片能够访问的地址访问是：**2^14 * 2^14 = 2^28 = 256M**, 又因为Tiny210一共有**4**块这样的芯片，所以一共可以访问的内存范围就是：**256M * 4 = 1G**。

**Tiny210：SDRAM = 1GB = 2^30 = 2^14(Row Addr) * 2^14(Col Addr) * 2^2(4,4块SDRAM)**

**CPU地址线和内存的关系**

CPU：32Bit不等于就有32条地址线，cpu可以发送32Bit的地址，但是**具体发送多少地址线是由内存控制器来决定的**。
例如：Addr0 - Addr26作为地址线，而Addr27 - Addr31作为其他用途，或者不用。


**不同数据位宽的外设的接线方式**

从上面的Mem原理图可以看出，Tiny210RAM有8根数据线，就意味这他是8位的数据宽度，如果有16根地址线，就是16位宽。
**位宽简单来说就是表示访问该外设的一个地址，所得到的数据宽度**，例如访问0x30000000得到**1个字节**，那么该外设就是**8位数据宽度**，如果返回**2个**或者**4个字节**，那么该外设就是**16位**或者**32位**数据宽度。

因为外设有不同的位宽，所以CPU与外设地址线的接线也就有不同。
假设CPU一个地址对应1B，外设一个地址对应2B，也就是说外设的数据宽度是16位的，那么假设CPU访问**0x3**地址的**一个字节**，则外设会把**索引为1的数据单元(含有2个字节)**返回与给MemCtl，MemCtl随后会把指定的字节返回给CPU。如下图：
![MemBit][4]
如果CPU访问地址0x2，外设还是会把索引为1的数据单元返回给MemCtl，因此不管访问0x2还是0x3,MemCtl最后得到的都是外设中索引为1的数据单元，所以地址：**0x2 = 0x10, 0x3 = 0x11**，地址的**第0位就与CPU无关**了，**不管第0位是1还是0,CPU都会得到索引为1的数据单元**，因此，在外设和SOC接线的时候，**Addr0可以不接**，这就是有些外设的地址线的前几根没有接的原因，都是应为外设的数据宽度与CPU的数据宽度不同导致的。
如果外设是**32位**的，那么**Addr0和Addr1就可以不接**了，原因你可以自行分析。


  [1]: https://cheng-zhi.github.io/img/post-2017-02-27-RAM-Like.png
  [2]: https://cheng-zhi.github.io/img/post-2017-02-27-Tiny210Mem.png
  [3]: https://cheng-zhi.github.io/img/post-2017-02-27-MemCtl.png
  [4]: https://cheng-zhi.github.io/img/post-2017-02-27-MemBit.png
