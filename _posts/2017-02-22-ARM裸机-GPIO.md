---
layout:     post
title:      "嵌入式Linux-ARM裸机-GPIO"
subtitle:   "ARM裸机"
date:       2017-02-22 12:00:00
author:     "陈登龙"
header-img: "img/post-bg-unix-linux.jpg"
catalog: true
tags:
    - 嵌入式Linux
---

# 嵌入式Linux-ARM裸机-GPIO


**一，什么是GPIO？**

**General Purpose Input Output (通用输入/输出) 简称为GPIO**。
在控制器芯片中，GPIO的表现形式为引脚，这些引脚具有复用个功能，不仅可以作为GPIO使用，也可以作为其他功能，例如中断。

**二，GPIO在内存的哪个位置？**

以Tiny210开发版为例，下面是它的内存模型：
![enter description here][1]
其中最上面的**SFRS为特殊功能寄存器区域**，，GPIO寄存器就在这片内存中。


**三，以Tiny210开发板为例，做4个关于GPIO的实验**

**1.环境配置**

你需要在一台**Linux**上配置**交叉编译工具链arm-linux-gcc**,并且你需要有一块**开发板**，然后准备一个**大SD卡**。

**2.实验一：使用汇编语言点亮LED灯**

我们使用**汇编语言**来点灯，需要**两个**文件，一个是**led_on.S**，在这里实现点亮LED的汇编代码，另一个是**Makefile**，用来编译代码。

LED原理图：
![LED][2]
**LED1引脚连接到CPU的GPJ2_0。**

下面是源码：
**led_on.S**

``` 
#gcc使用GNU的汇编格式，一般都加上这个.text伪指令
.text
#声明一个全局的_start段，加上_否则make会有警告
.global _start
#_start段代码
_start:
	#根据Tiny210的原理图可以查到LED的连接到GPJ2_0，所以这里将GPJ2CON[0]配置为输出模式。
	#将GPJ2CON的地址0xE0200280加载到R0寄存器中。这时候LDR作为伪指令使用。
	LDR R0, =0xE0200280
	#根据Tiny210手册，将GPJ2CON[0]置为0001,即16进制1,即可配置该引脚为输出模式。
	MOV R1, #0x00000001
	#将R1的值0x1写入R0指向的内存0xE0200280中。可以看出该内存地址正是在SFRS区域。
	STR R1, [R0]

	#将GPJ2DAT的地址0xE0200284加载到R0寄存器中。
	LDR R0, =0xE0200284
	#将R1赋值为0
	MOV R1, #0x00
	#根据原理图，将引脚输出0,则可以点亮LED灯。
	STR R1, [R0]

#一个死循环，使得程序在这里停止。
loop:
	#跳转到loop段执行，不返回。
	B loop
```

**Makefile：**

``` makefile
#依赖关系
led_on.bin:led_on.S
	#将汇编文件编译成目标文件
	arm-linux-gcc -c -o led_on.o led_on.S
	#加上头信息，并在运行时将目标文件链接到0x00000000地址处
	arm-linux-ld -Ttext 0x00000000 led_on.o -o led_on.elf
	#-O进行优化，-S去掉头信息，objcopy拷贝成bin格式文件
	arm-linux-objcopy -O binary -S led_on.elf led_on.bin
	#使用SD卡烧写，使用光盘提供的mkv210工具，烧写前16K到SD卡第一扇区
	mkv210 led_on.bin 210.bin
	
#make clean的伪指令	
clean:
	rm -f *.o *.elf *.bin
```

编译：

``` 
	make
```

会生成led_on.bin, led_on.elf,**210.bin**,然后将210.bin烧写到SD卡中，插入SD卡，然后执行：

``` 
sudo dd iflag=dsync oflag=dsync if=210.bin of=/dev/sdb seek=1
```

测试：
插入SD卡，设置开发板从SD卡启动，开机即可看到LED灯亮，实验成功。


**3.实验二：使用C语言点亮LED灯**

使用C语言点亮LED需要3个文件：**led_on.c, led_on.S, Makefile**。

**led_on.S:**

``` 
#代码很简单，就是跳转到C语言的main函数执行，main执行完后，执行死循环loop。
.text
.global _start
_start:
	#Jump to C main.
	BL main
	B loop
loop:
	B loop
```

**led_on.c:**

``` c
/* 
 * 将控制寄存器和数据寄存器的地址转换成unsigned long类型指针，然后取出里面的内容
 * volatile是表示禁止编译器对这个行代码优化
 */
#define GPJCON	(*((volatile unsigned long*)0xE0200280))
#define GPJDAT	(*((volatile unsigned long*)0xE0200284))

int main(void) {
	/* 将控制寄存器最后4位设置为1,表示设置为输出模式. */
	GPJCON = 0x00000001;
	/* 将数据寄存器输出设置为0， 即可点亮LED. */
	GPJDAT = 0x00;
	/* 必须返回到汇编代码中执行. */
	return 0;
}
```


**Makefile:**/* 必须返回到汇编代码中执行. */

``` makefile
#添加对led_on.c的依赖
led_on.bin:led_on.S led_on.c
	arm-linux-gcc -c -o led_on_s.o led_on.S
	#编译led_on.c
	arm-linux-gcc -c -o led_on_c.o led_on.c
	#加上对led_on.o的链接
	arm-linux-ld -Ttext 0x00000000 led_on_s.o led_on_c.o -o led_on.elf
	arm-linux-objcopy -O binary -S led_on.elf led_on.bin
	mkv210 led_on.bin 210.bin

clean:
	rm -f *.o *.elf *.bin
```

编译，烧写，测试跟第一个实验相同，结果也是LED被点亮。



**4.实验三：延时控制峰鸣器**

可以使用GPIO来控制峰鸣器响或者不响，方法跟控制LED几乎相同。我们需要3个文件：**start.S, main.c, Makefile**

峰鸣器原理图:
![峰鸣器][3]

这是一个NPN三极管，给基级输入1,三极管导通，buzzer两端有电压，峰鸣器会报警，给基级输入0,三极管截至，buzzer两端无电压，峰鸣器不会报警。根据原理图和数据手册查找到**XpwmTOUT0这个引脚连接到GPD0_0**。

**start.S:**

``` 
#代码很简单，就是跳转到C语言的main函数执行，main执行完后，执行死循环loop。
.text
.global _start
_start:
	#Jump to C main.
	BL main
	B loop
loop:
	B loop
```

**main.c:**

代码大同小异，只是多个3个函数。
``` c
#define GPD0CON	(*(volatile unsigned long*)0xE02000A0)
#define GPD0DAT	(*(volatile unsigned long*)0xE02000A4)

/* 延时时间 */
#define DELAY_TIME 0x50000

void buzzer_on(void);
void buzzer_off(void);
void delay(unsigned long time);


int main(void) {
	/* Set GPD0_0 output mode. */
	GPD0CON |= (1 << 0);
	
	while (1) {
		buzzer_on();
		delay(DELAY_TIME);
		buzzer_off();
		delay(DELAY_TIME);
	}
	/* 必须返回到汇编代码中执行. */
	return 0;
}

/*
 * Start buzzer.
 */
void buzzer_on(void) {
	GPD0DAT |= (1 << 0);
}


/*
 * Stop buzzer.
 */
void buzzer_off(void) {
	GPD0DAT &= ~(1 << 0);
}


/*
 * A simple delay fun.
 */
void delay(unsigned long time) {
	volatile unsigned long count = time;
	while (count--);
}
```

**Makefile:**

``` makefile
#依赖关系
buzzer.bin : start.o main.o
	#$^表示所有的不同名，不重复的依赖文件
	arm-linux-ld -Ttext 0x00000000 $^ -o buzzer.elf
	arm-linux-objcopy -O binary -S buzzer.elf buzzer.bin
	mkv210 buzzer.bin 210.bin

#编译所有的.S文件,$@表示目标文件名，$<表示第一个依赖文件名称。
%.o : %.S
	arm-linux-gcc -c $< -o $@

#编译所有的.c文件
%.o : %.c
	arm-linux-gcc -c $< -o $@

clean:
	rm -f *.o *.elf *.bin
	
```

编译，烧写，测试跟第一个实验相同，**实验现象：峰鸣器间断的报警**。


**5.实验四：通过key来控制峰鸣器**

Key原理图：
![Key][4]
当**key按下**时，引脚**输入低电平**，**没有按下**时**输入高电平**，端口接了上拉电阻，这里就不上图了。
该引脚接了**GPH0_0**。

这个实验的start.S,Makefile代码跟上个实验的相同，main.c不同：

``` c
/* 定义key和buzzer的控制和数据寄存器. */
#define GPD0CON (*((volatile unsigned long*)0xE02000A0))
#define GPD0DAT (*((volatile unsigned long*)0xE02000A4))
#define GPH2CON (*((volatile unsigned long*)0xE0200C40))
#define GPH2DAT (*((volatile unsigned long*)0xE0200C44))


void buzzer_on(void);
void buzzer_off(void);


int main(void) {
	/* Config buzzer output mode. */
	GPD0CON |= (1 << 0);
	
	/* Config key input mode. */
	GPH2CON &= ~(1 << 0);

	while (1) {
		/* 如果检查到key的数据寄存器输入1,则表示key没有按下，buzzer不报警. */
		if (GPH2DAT & (1 << 0)) {
			buzzer_off();
		} else {
		/* 如果检查到key的数据寄存器输入0,则表示key按下，buzzer报警. */
			buzzer_on();
		}
	}
	/* 必须返回到汇编代码中执行. */
	return 0;
}


/*
 * Start buzzer.
 */
void buzzer_on(void) {
	GPD0DAT |= (1 << 0);
}


/*
 * Stop buzzer.
 */
void buzzer_off(void) {
	GPD0DAT &= ~(1 << 0);
}

```

编译，烧写，测试跟第一个实验相同，**实验现象：按下key，buzzer报警，松开key，buzzer不报警**。


**四，总结**

**控制GPIO的思路**：

1.查看要控制的外设原理图，找到控制端口，判断输入还是输出。

2.在ARM主板原理图中查找对应的GPIO口。

3.在芯片手册中查找对应GPIO的文档，找到控制寄存器和数据寄存器地址。

4.在C文件中定义控制寄存器和数据寄存器。

5.根据输入或者输出来配置控制寄存器。

6.根据输入或者输出来读取数据寄存器或者写入数据寄存器。

嵌入式开发中，**编程思路很重要**。




  [1]: https://cheng-zhi.github.io/img/post-2017-02-22-Tiny210-Mem.png
  [2]: https://cheng-zhi.github.io/img/post-2017-02-21-LED.png
  [3]: https://cheng-zhi.github.io/img/post-2017-02-21-NPN.png
  [4]: https://cheng-zhi.github.io/img/post-2017-02-21-Key.png
