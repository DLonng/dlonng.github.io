---
layout:     post
title:      "Busybox-启动脚本"
subtitle:   "S5PV210 Busybox "
date:       2017-03-15 21:00:00
author:     "陈登龙"
header-img: "img/post-bg-EMSLinux.jpg"
catalog: true
tags:
    - 嵌入式Linux
---

# Busybox-启动脚本

**一，Busybox简介**

Busybox又叫做瑞士军刀，在嵌入式Linux中，我们经常使用Busybox作为我们在/bin下的可执行文件。这次我们简要分析下Busybox的启动脚本，以及配置我们自己的rootfs使得可以在系统刚启动时自动运行我们自己的程序。

**二，Busybox简要分析**

**1.我们进入busybox目录**
![busybox][1]


**2.打开init/init.c，这是init的主函数**

系统启动后最先启动init进程，进程号为1，init进程对应：**linuxrc -> /bin/busybox**.

我们定位到init_main这个函数：我们只需要看这几部分

``` c
int init_main(int argc UNUSED_PARAM, char **argv)
{
	...

	/* Figure out where the default console should be 必要的控制台初始化 */
	console_init();
	set_sane_term();
	xchdir("/");
	setsid();

	/* Make sure environs is set to something sane 设置环境变量 */
	putenv((char *) "HOME=/");
	putenv((char *) bb_PATH_root_path);
	putenv((char *) "SHELL=/bin/sh");
	putenv((char *) "USER=root"); /* needed? why? */
	
...

	...
		/* Not in single user mode -- see what inittab says */

		/* NOTE that if CONFIG_FEATURE_USE_INITTAB is NOT defined,
		 * then parse_inittab() simply adds in some default
		 * actions(i.e., runs INIT_SCRIPT and then starts a pair
		 * of "askfirst" shells */
		/* 解析inittab文件，initab文件中是系统运行时启动的程序脚本，我们可以配置它 */
		parse_inittab();
...
	 

	/* Now run everything that needs to be run */

	/* First run the sysinit command 运行SYSINT命令，最终会运行/etc/init.d/rcS脚本 */
	run_actions(SYSINIT);
 
...                          

```

**parse_inittab函数**：这个函数是用来解析inittab文件中的启动命令的，了解即可

``` c
/* NOTE that if CONFIG_FEATURE_USE_INITTAB is NOT defined,
 * then parse_inittab() simply adds in some default
 * actions(i.e., runs INIT_SCRIPT and then starts a pair
 * of "askfirst" shells).  If CONFIG_FEATURE_USE_INITTAB
 * _is_ defined, but /etc/inittab is missing, this
 * results in the same set of default behaviors.
 */
static void parse_inittab(void)
{
#if ENABLE_FEATURE_USE_INITTAB
	char *token[4];
	parser_t *parser = config_open2("/etc/inittab", fopen_for_read);

	if (parser == NULL)
#endif
	{
		/* No inittab file -- set up some default behavior */
		/* Reboot on Ctrl-Alt-Del */
		new_init_action(CTRLALTDEL, "reboot", "");
		/* Umount all filesystems on halt/reboot */
		new_init_action(SHUTDOWN, "umount -a -r", "");
		/* Swapoff on halt/reboot */
		if (ENABLE_SWAPONOFF)
			new_init_action(SHUTDOWN, "swapoff -a", "");
		/* Prepare to restart init when a QUIT is received */
		new_init_action(RESTART, "init", "");
		/* Askfirst shell on tty1-4 */
		new_init_action(ASKFIRST, bb_default_login_shell, "");
//TODO: VC_1 instead of ""? "" is console -> ctty problems -> angry users
		new_init_action(ASKFIRST, bb_default_login_shell, VC_2);
		new_init_action(ASKFIRST, bb_default_login_shell, VC_3);
		new_init_action(ASKFIRST, bb_default_login_shell, VC_4);
		/* sysinit */
		new_init_action(SYSINIT, INIT_SCRIPT, "");
		return;
	}

#if ENABLE_FEATURE_USE_INITTAB
	/* optional_tty:ignored_runlevel:action:command
	 * Delims are not to be collapsed and need exactly 4 tokens
	 */
	while (config_read(parser, token, 4, 0, "#:",
				PARSE_NORMAL & ~(PARSE_TRIM | PARSE_COLLAPSE))) {
		/* order must correspond to SYSINIT..RESTART constants */
		static const char actions[] ALIGN1 =
			"sysinit\0""respawn\0""askfirst\0""wait\0""once\0"
			"ctrlaltdel\0""shutdown\0""restart\0";
		int action;
		char *tty = token[0];

		if (!token[3]) /* less than 4 tokens */
			goto bad_entry;
		action = index_in_strings(actions, token[2]);
		if (action < 0 || !token[3][0]) /* token[3]: command */
			goto bad_entry;
		/* turn .*TTY -> /dev/TTY */
		if (tty[0]) {
			if (strncmp(tty, "/dev/", 5) == 0)
				tty += 5;
			tty = concat_path_file("/dev/", tty);
		}
		new_init_action(1 << action, token[3], tty);
		if (tty[0])
			free(tty);
		continue;
 bad_entry:
		message(L_LOG | L_CONSOLE, "Bad inittab entry at line %d",
				parser->lineno);
	}
	config_close(parser);
#endif
}

```

这里介绍下inittab文件的配置：**initab文件是init程序的默认配置文件。**
每一行的格式：**optional_tty:ignored_runlevel:action:command**


其中ignored_runlevel有下面这些：

1.sysinit - 为init提供初始化命令行的路径及脚本程序

2.respawn - 每当相应的进程终止时会重新启动

3.askfirst - 类似respawn，在重启后会等待用户按下Enter键

4.wait - 告诉init必须等到相应的进程完成之后才能继续执行

5.once - 只能执行一次相应的进程

6.restart - 当init重启时，执行相应的进程，通常仍然执行init

7.ctlaltdel - 按下Ctrl+Alt+Del后，执行相应的进程

8.shutdown - 当系统关机后，执行相应的进程

可以发现，如果没有inittab文件，系统启动时会运行rcS启动脚本，如果有inittab文件，系统会先运行inittab文件，然后运行rcS脚本，即不管如何**系统最后都会运行rcS启动脚本**。


启动流程如下：**init -> inittab -> /etc/init.d/rcS -> /etc/init.d/S[0-9][0-9]* -> app**

那么我们如何在嵌入式系统中定制我们的系统启动流程呢？我们介绍**2种**方法：

**1.** 修改启动脚本/etc/init.d/rcS来定制启动流程。

**2.** 借鉴Linux的启动管理，将要启动的程序命名为SNAppName, 例如S01hello，然后利用rcS脚本循环执行每个S开头的程序，这也是Linux的启动原理，只不过我们这里去掉了系统的运行级别这一环节。

**这两种方法有什么区别呢？**

/etc/init.d/rcS主要用来配置**系统的启动程序**，/etc/init.d/S[0-9][0-9]*主要用来**配置用户的启动程序**。

不过我们在嵌入式中，为了将服务分离，体现模块化的思想，我们建议使用第二种方法。

**三，配置HelloWorld自动启动**

**1.** 我们需要先**静态交叉编译**HelloWorld.c, 生成一个名为S01hello的可执行文件，为什么叫S01hello？S代表start，01代表编号(编号越小越先启动)，hello是真正的可执行文件的有效名称。

``` swift
arm-linux-gcc -static hello.c -o S01hello
```

**2.** 给S01hello加上可执行权限

``` perl
chmod a+x S01hello
```

**3.** 编写rcS

``` bash
  1 #! /bin/sh
  2 
  3 echo "--------------------------rcS start!----------------------------"
  4 
  5 for script in /etc/init.d/S[0-9][0-9]*
  6 do
  7     if [ -x $script ] ;then
  8         echo "RCS : $script"
  9         /bin/sh -c $script
 10     fi
 11 done
 12 
 13 echo "---------------------------rcS end!-----------------------------"
```
这个循环的意思是：循环执行/etc/init.d/下名称类似与S01hello的所有程序。这样我们的hello程序就可以自动启动了，因为busybox中的init进程会自动启动rcS脚本。

**4.** 重启开发板，即可看到rcS start, 和rcS end的相关信息，而且是在运行rootfs之前。这样我们的自启动程序就配置完成了，在以后需要配置一个程序自启动时，只需要将这个程序命名为S[0-9][0-9]*的格式，然后放到/etc/init.d/下即可，如果不想这个程序自启动时，只需要将它重命名为K[0-9][0-9]*的格式即可，K是Kill的意思。



  [1]: https://cheng-zhi.github.io/img/Busybox/post-2017-03-15-Busybox.png
