---
title: C/C++ 面试易错补充一
date: 2019-04-09 17:00:00
---
# C/C++ 面试易错补充一
***
> 版权声明：本文为 {{ site.name }} 原创文章，可以随意转载，但必须在明确位置注明出处！

考完研了，也休息了半个月了，开始准备找 C/C++ 的实习工作，记录一些重要的 C++ 语法特性：

- `for (int i = 0; i <= 10; i++)` 中的 i 位于语句作用域
- 变量存储类型：自动，寄存器，静态，外部
- 引用是对象的另一个名字，主要作为函数形参使用
- const 引用必须被定义为 const 类型
- break 用于跳出最近的循环或 switch 语句
- `ifstream(input file stream)`, `ofstream(output file stream)`
- 在 C++ 中尽量避免使用指针和数组，用引用代替指针，vector 代替数组，string 代替 C 风格字符串
- 指向 const 对象的指针，指针指向的值不能改变：`const int a = 10; const int *pa = &a;`
- const 指针，指针不能改变指向：`int a = 0; int *const = &a;`
- 返回指针的函数称为指针函数
- C++ 中参数和返回值的传递方式：引用传递，值传递，指针传递
- 引用传递的是引用对象的内存地址
- 指针是一个实体，而引用仅是个别名
- 引用只能在定义时初始化，之后不可变，而指针可变
- 引用没有 const，指针有 const
- 引用不能为空，指针可以为空
- 引用不需要分配内存区域
- sizeof(引用) = 变量内存大小，sizeof(指针) = 指针本身的内存大小
- 面向过程：程序 = 算法 + 数据
- 面向对象：程序 = 对象 + 消息，对象内部还是算法和数据
- 结构体用来处理较少的程序基础数据，而类用来处理复杂逻辑
- 含有纯虚函数的类成为抽象类（抽象接口）
- 派生类和基类共用静态成员
- 类的静态成员可以成为成员函数的可选参数
- 类的静态成员类型可以是所属类的类型
- 类的静态方法只能访问静态成员
- 多态性在 C++ 中通过虚函数和继承机制来实现
- 公有继承保持访问级别，保护继承 public 和 protected 都变为 protected 成员，私有继承全部变为私有成员
- 基类中的 private 成员不能被继承
- 调用复制构造函数：对象通过值传递传入函数体，对象通过值传递从函数返回，一个对象通过另一个对象初始化
- C++ 支持函数参数个数不确定：`int max(int num, ...)`
- 在内联函数内不允许用循环和 switch 语句，如果存在则视为普通函数编译代码
- 程序中尽量少使用指针形参，会降低可读性
- 静态函数没有 this 指针
- 类的私有成员不可以被外部类访问，但是可以通过宏定义访问类的私有成员：`#define private public`，这是一种非常规手段
- 函数重载是指在相同的作用域中，具有相同的名称而形参列表不同的多个函数，返回值也可以不同，但不是必须的
- STL 和 Boost 等都采用模板技术（大量使用了类模板），使用泛型编程
- 模板未使用前，编译器不会编译该模板，只有在模板被实例化时才生成相应类型的代码
- STL 使用迭代器来遍历容器
- STL 顺序容器：vector, deque, list
- STL 关联容器：set(唯一元素的集合), multset(允许一个键对应多个实例), map(键-值), multimap(允许一个键对应多个实例)
- begin 迭代器指向容器中的第一个元素，end 迭代器指向最后一个元素的下一个位置
- 不能存储 end() 迭代器的返回值，当进行插入或删除操作后，end() 所指向的元素可能不存在，迭代器失效，应该每次重新计算 end()
- 泛型编程：独立于任何特定类实现的方式编写代码，针对不同的类型提供不同的实现
- 如何实现泛型编程：模板技术，函数重载

> {{ site.prompt }}

<div  align="center">
<img src="{{ site.url }}/images/wechart.jpg" width = "200" height = "200"/>
