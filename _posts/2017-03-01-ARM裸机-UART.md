---
layout:     post
title:      "ARM裸机-UART"
subtitle:   "ARM Tiny210 UART"
date:       2017-02-28 22:00:00
author:     "陈登龙"
header-img: "img/post-bg-unix-linux.jpg"
catalog: true
tags:
    - ARM裸机
---


# ARM裸机-UART


**一，串口简介**

**通用异步收发器**简称**UART**,即**UNIVERSAL ASYNCHRONOUS RECEIVER AND TRANSMITTER**。
它用来传输**串行**数据。发送数据时,CPU 将并行数据写入 UART,UART 按照一定的格式在一根电线上串行发出;接收数据时,UART 检测另一根电线的信号,将串行数据收集在缓冲区中,CPU 即可读取 UART获得这些数据。

**串口组成**

TXD：数据传输线,连接另一个模块的RXD

RXD：数据接收线,连接另一个模块的TXD

GND：地线


串口数据常见组成方式：
**1个起始位(固定)，8个数据位，0个校验位，1个停止位**。
如下图所示：
![DataFormat][1]

**二，串口通信基本概念**

**1.什么是通信？**
简单来说，两个不同模块之间的**数据交换**就叫做通信。

**2.常见通信方式**
**串行通信(Serial Communication)**：
特点：传输速度慢，远距离传输比较经济，传输线路少

串行通信有可以分为下面几种类型：
**同步**通信：受同一根时钟线控制，受时钟控制。
如下图：先发送同步条件用来同步，同步之后，再发送数据。
![SYNC][2]

**异步**通信：不受同一根时钟线控制，受波特率bps控制。bps是**每秒钟传输二进制的位数**，常用:9600,115200。

**单工**通信：只能发送或者接收，只有一根数据线。
如下图：
![单工][3]

**半双工**通信：可以发送和接收数据，但是不能同时进行，也只有一根数据线。
如下图：
![半双工][4]

**全双工**通信：可以同时发送和接收数据，有2根数据线。
如下图：
![全双工][5]

注意：**串口是一种异步全双工串行通信方式**。


**并行通信(Paraller Communication)**：传输速度快，远距离传输成本高，传输线路多。

![并行][9]



**3.常见通信协议**

什么是通信协议呢？
定义:两个模块之间的通信方式相同的约束条件。

**串行通信协议**
**UART**：主要用于模块之间的通信。单片机之间，处理器之间，下位机和上位机之间通信等。

**IIC**：主要用于芯片之间。

**SPI**：主要用于Flash，SD卡等，速度较快。

**1_wrie**：温度传感器DS18B20。

**IIS**：主要用于音频信号解析领域。

**SDIO**：主要用于SD卡领域

**USB**：主要用于手机，电脑等消费电子领域

**CAN**：主要用于汽车电子领域

**并行通信协议**
Intel公司**8080并口**：主要用于LCD显示器，RAM(内存交换速度)，Flash等领域。




**三，Tiny210串口编程**

在 Tiny210 中,UART 提供了 **4** 对独立的异步串口 I/O 端口,有 4 个独立的通道,每个通道可以工作于 **DMA** 模式或者**中断**模式。
其中,通道 0 有 256byte 的的发送 FIFO 和 256byte 的接收 FIFO,通道 1 有 64byte 的的发送 FIFO 和 64byte 的接收 FIFO,而通道 2 和 3 只有 16byte 的的发送 FIFO和 16byte 的接收 FIFO。

下面是Tiny210的UART图：
![UART][6]

UART 使用标准的 TTL/CMCOS 逻辑电平来表示数据,为了**增强数据抗干扰能力和提高传输长度**,通常将 **TTL/CMOS** 逻辑电平转换为 **RS-232** 逻辑电平,查看原理图可知 Tiny210 使用的是 **SP3232芯片**,使用的是 TXD0 和 RXD0:
![UART-PCB][7]

查看UART对应的GPIO：
![UART-GPIO][8]

可以看到，控制UART的引脚是GPA0，所以后面我们就通过配置UART控制器来配置串口。
什么是**UART控制器**呢？
因为串口有硬件协议要求，通过软件去模拟该协议是可行的，但是对于软件成本来说不值得，一般情况下，芯片公司会提供这种标准协议的控制器，软件工程师只需要**告知控制器工作的方式**，然后就直接放数据，该控制器就可以**自动**把刚才的数据按照之前**配置**的工作模式发送出去。
因此我们只需要向相关的寄存器中写入数据，之后UART控制器就会自动配置串口了。

下面的UART Demo包括这些文件：**main.c, uart.c, uart.h, gpio.h, cpu_io.h,start.S, Makefile**

**start.S**

``` 
.global _start
.global main

_start:
	#直接跳转到main
	BL main

loop:
	B loop

.end
```

**gpio.h**

``` c
/*
 * 包含GPIO结构体的定义，定义顺序参考数据手册。
 */
 
 #ifndef __ASM_ARCH_GPIO_H
#define __ASM_ARCH_GPIO_H

/* GPIO结构体定义 */
struct s5pc1xx_gpio_bank {
    unsigned int    con;
    unsigned int    dat;
    unsigned int    pull;
    unsigned int    drv;
    unsigned int    pdn_con;
    unsigned int    pdn_pull;
    unsigned char   res1[8];
};

/* GPIO 定义 */
struct s5pv210_gpio {
    struct s5pc1xx_gpio_bank gpio_a0;
    struct s5pc1xx_gpio_bank gpio_a1;
    struct s5pc1xx_gpio_bank gpio_b;
    struct s5pc1xx_gpio_bank gpio_c0;
    struct s5pc1xx_gpio_bank gpio_c1;
    struct s5pc1xx_gpio_bank gpio_d0;
    struct s5pc1xx_gpio_bank gpio_d1;
    struct s5pc1xx_gpio_bank gpio_e0;
    struct s5pc1xx_gpio_bank gpio_e1;
    struct s5pc1xx_gpio_bank gpio_f0;
    struct s5pc1xx_gpio_bank gpio_f1;
    struct s5pc1xx_gpio_bank gpio_f2;
    struct s5pc1xx_gpio_bank gpio_f3;
    struct s5pc1xx_gpio_bank gpio_g0;
    struct s5pc1xx_gpio_bank gpio_g1;
    struct s5pc1xx_gpio_bank gpio_g2;
    struct s5pc1xx_gpio_bank gpio_g3;
    struct s5pc1xx_gpio_bank gpio_i;
    struct s5pc1xx_gpio_bank gpio_j0;
    struct s5pc1xx_gpio_bank gpio_j1;
    struct s5pc1xx_gpio_bank gpio_j2;
    struct s5pc1xx_gpio_bank gpio_j3;
    struct s5pc1xx_gpio_bank gpio_j4;
};

/* GPIO 基地址 */
#define S5PV210_GPIO_BASE (0xE0200000)

#endif
 
```

**cpu_io.h**

``` c
/*
 * 主要定义了对寄存器的操作
 */
 
#ifndef _S5PV210_CPU_H
#define _S5PV210_CPU_H

#define	__REG(x)		(*(volatile unsigned int *)(x))

#define readb(a)		(*(volatile unsigned char *)(a))
#define readw(a)		(*(volatile unsigned short *)(a))
#define readl(a)		(*(volatile unsigned int *)(a))

#define writeb(v,a)		(*(volatile unsigned char *)(a) = (v))
#define writew(v,a)		(*(volatile unsigned short *)(a) = (v))
#define writel(v,a)		(*(volatile unsigned int *)(a) = (v))

#endif
```


**uart.h**

``` c
#ifndef UART_H
#define UART_H

/* 串口寄存器的结构体定义 */
struct s5pv210_uart
{
	unsigned int ulcon;
	unsigned int ucon;
	unsigned int ufcon;
	unsigned int umcon;
	unsigned int utrstat;
	unsigned int uerstat;
	unsigned int ufstat;
	unsigned int umstat;
	unsigned int utxh;
	unsigned int resl[3];
	unsigned int urxh;
	unsigned int res2[3];
	unsigned int ubrdiv;
	unsigned int udivslot;
	unsigned int res3[2];
	unsigned int res4[0x3d0];
};

/* UART基地址 */
#define S5PV210_UART_BASE 0XE2900000

void uart_init(void);

void my_putc(char send_ch);

void my_puts(const char *send_str);

#endif

```

**uart.c**

``` c
#include "cpu_io.h"
#include "gpio.h"
#include "uart.h"

/*
 * 串口初始化
 */
void uart_init(void)
{
	struct s5pv210_gpio* gpio_base = (struct s5pv210_gpio*)S5PV210_GPIO_BASE;
	struct s5pv210_uart* uart_base = (struct s5pv210_uart*)S5PV210_UART_BASE;

	/* Config pin mode. */
	unsigned int var = 0;

	/* Config GPA0CON. */
	var = readl(&gpio_base->gpio_a0.con);
	var &= ~(0xFFFFFFFF << 0);
	var |= (0x22222222 << 0);
	writel(var, &gpio_base->gpio_a0.con);
	
	/* Config GPA1CON. */
	var = readl(&gpio_base->gpio_a1.con);
	var &= ~(0xFFFF << 0);
	var |= (0x2222 << 0);
	writel(var, &gpio_base->gpio_a1.con);


	/* Data bit:8, parity:no, stop bit:1*/
	__REG(&uart_base->ulcon) = 0x3;

	/* Enable FIFO. */
	__REG(&uart_base->ufcon) = 0x1;

	/* No flow ctl. */
	__REG(&uart_base->umcon) = 0x0;
	
	/* PCLK, disable INT, enable UART send and recive. */
	__REG(&uart_base->ucon) = 0x5;

	/* Config BPS = 115200 */
	__REG(&uart_base->ubrdiv) = 35;
	__REG(&uart_base->udivslot) = 0x1;
}


/*
 * Print one char.
 */
void my_putc(char send_ch)
{
	struct s5pv210_uart* uart_base = (struct s5pv210_uart*)S5PV210_UART_BASE;

	while (!(__REG(&uart_base->utrstat) & (0x1 << 2)));

	__REG(&uart_base->utxh) = send_ch;

}


/*
 * Printf one string.
 */
void my_puts(const char* send_str)
{
	while (*send_str)
	{
		my_putc(*send_str);
		send_str++;
	}
}

```

**main.c**

``` c  
#include "uart.h"
 

int main()
 
 	/* 初始化串口 */
	uart_init();
	
	/* 输出3个字符 */
	my_putc('A');
	my_putc('B');
	my_putc('C');

	/* 输出一个字符串 */
	my_puts("Hello World"); 
	return 0;
}

```

**map.lds**

lds是链接脚本文件，它规定了可执行文件中目标文件的链接顺序。

``` 
OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
OUTPUT_ARCH(arm)
ENTRY(_start)
SECTIONS
{
	. = 0X0;

	. = ALIGN(4);
	.text	:
	{
		start.o
		*(.text)
	}

	. = ALIGN(4);
	.rodata	:
	{
		*(.rodata)
	}

	. = ALIGN(4);
	.data	:
	{
		*(.data)
	}

	. = ALIGN(4);
	.bss	:
	{
		*(.bss)
	}
}

```




**Makefile**

这是一个在交叉开发环境下的通用Makefile，可以好好研究下。

``` makefile
#Design by orange for S5PV210

#define var
TARGET := 210.bin
BUILD  := 210

ENV     ?= SD
SDTOOLS := ./mk210

COBJS  += main.o
COBJS  += start.o
COBJS  += led.o uart.o


CROSS_COMPILE := arm-linux-

CC       := $(CROSS_COMPILE)gcc
LD       := $(CROSS_COMPILE)ld
OBJCOPY  := $(CROSS_COMPILE)objcopy

CFLAGS   += -Wall	#Add compile wall
CFLAGS   += -I./inc	#Add include path

LDFLAGS  += -Tmap.lds
ifeq ($(ENV),SD)
LDFLAGS  +=	-Ttext=0xD0020010	#SD card link address for UART			
#LDFLAGS  += -Ttext=0x0			#SD card link address			
else
LDFLAGS  +=	-Ttext=0x20000000	#SDRAM link address			
endif



#Way
all : $(TARGET)

ifeq ($(ENV),RAM)
#SDRAM
$(TARGET) : $(BUILD)
	$(OBJCOPY) -O binary $^ $@
	cp $@ ../binary -f
else
#SD Card
$(TARGET) : $(BUILD)
	$(OBJCOPY) -O binary $^ $@.TMP
	$(SDTOOLS) $@.TMP $@
	cp $@ ../binary -f
endif

$(BUILD) : $(COBJS)
	$(LD) $(LDFLAGS) -o $@ $^

%.o : %.c
	$(CC) $(CFLAGS) -c -o $@ $^

%.o : %.S
	$(CC) $(CFLAGS) -c -o $@ $^
	
clean:
	rm -f $(TARGET) $(BUILD) *.o *.TMP 
```

注意这行代码：

``` makefile
LDFLAGS  +=	-Ttext=0xD0020010	#SD card link address for UART			
```

因为程序的编译链接地址和程序的实际运行地址不同，程序原本是从0x0开始执行但是因为S5PV210内置的iROM将SD中的前16KB搬移到了0xD002_0000处，所以程序的实际运行首地址是0xD002_0010, 所以程序中**使用绝对跳转的代码将会出错**，而使用相对跳转的代码则仍可以运行正常，**my_puts("Hello World\n");使用的是绝对地址来跳转**，my_puts使用"Hello World\n"的首地址，程序在**运行**时对"Hello World\n"的**首地址定位**错误，所以程序不能在串口上打印出Hello World，在更改了Makefile中SD卡的链接地址为0xD0020010后，程序即可运行正常。

位置相关跳转-绝对跳转-直接利用地址跳转
位置无关代码-相对跳转-利用offset跳转



make之后，烧写到SD卡中，用下面的命令：

``` 
sudo dd iflag=dsync oflag=dsync if=210.bin of=/dev/sdb seek=1
```

打开CRT，上电之后可以看到：**ABCHelloWorld**





























  [1]: https://cheng-zhi.github.io/img/UART/post-2017-03-01-UartDataFormat.png
  [2]: https://cheng-zhi.github.io/img/UART/post-2017-03-01-SYNC.png
  [3]: https://cheng-zhi.github.io/img/UART/post-2017-03-01-DanGong.png
  [4]: https://cheng-zhi.github.io/img/UART/post-2017-03-01-BanGong.png
  [5]: https://cheng-zhi.github.io/img/UART/post-2017-03-01-QuanGong.png
  [6]: https://cheng-zhi.github.io/img/UART/post-2017-03-01-210UART.png
  [7]: https://cheng-zhi.github.io/img/UART/post-2017-03-01-UARTPCB.png
  [8]: https://cheng-zhi.github.io/img/UART/post-2017-03-01-UARTGPIO.png
  [9]: https://cheng-zhi.github.io/img/UART/post-2017-03-01-ParCom.png
