---
title: 规划算法 - 自动驾驶常见规划算法基本原理总结
date: 2021-03-15 20:00:00
---
# 规划算法 - 自动驾驶常见规划算法基本原理总结
***
> 版权声明：本文为 {{ site.name }} 原创文章，可以随意转载，但必须在明确位置注明出处！

上学期末看了一些经典规划算法的博客和论文，这篇文章总结下这些方法的基本原理。

## Dijkstra

Dijkstra 算法用来寻找图形中节点之间的最短路径。在Dijkstra算法中，需要计算每一个节点距离起点的总移动代价。同时，还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。

## A*

A Star 算法是一种很常用的路径查找和图形遍历算法，它可以被认为是Dijkstra算法的扩展。由于借助启发函数的引导，A*算法通常拥有更好的性能。

BFS 从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向外扩散，直到找到终点。

在执行算法的过程中，每个点需要记录达到该点的前一个点的位置 -- 可以称之为父节点。这样做之后，一旦到达终点，便可以从终点开始，反过来顺着父节点的顺序找到起点，由此就构成了一条路径。

A*算法通过下面这个函数来计算每个节点的优先级(从起始点出发走到当前的花费 G，加上预计到达终点的花费 H)：

```
f(n) = g(n) + h(n)
```

- f(n)是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。
- g(n) 是节点n距离起点的代价。
- h(n)是节点n距离终点的预计代价，这也就是A*算法的启发函数。

A*算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。

### 启发函数

启发函数会影响A*算法的行为

- 在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时算法就退化成了Dijkstra算法。
- 如果h(n)始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。
- 如果h(n)完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。
- 如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。

通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。对于网格形式的图，有以下这些启发函数可以使用：

- 如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。
- 如果图形中允许朝八个方向移动，允许斜着朝邻近的节点移动，则可以使用对角距离。
- 如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）

伪代码：

```
* 初始化open_set和close_set；
* 将起点加入open_set中，并设置优先级为0（优先级最高）；
* 如果open_set不为空，则从open_set中选取优先级最高的节点n：
    * 如果节点n为终点，则：
        * 从终点开始逐步追踪parent节点，一直达到起点；
        * 返回找到的结果路径，算法结束；
    * 如果节点n不是终点，则：
        * 将节点n从open_set中删除，并加入close_set中；
        * 遍历节点n所有的邻近节点：
            * 如果邻近节点m在close_set中，则：
                * 跳过，选取下一个邻近节点
            * 如果邻近节点m也不在open_set中，则：
                * 设置节点m的parent为节点n
                * 计算节点m的优先级
                * 将节点m加入open_set中
```

参考博客：

- https://zhuanlan.zhihu.com/p/54510444
- https://www.jianshu.com/p/9f911f44913b

## PRM

参考博客

- https://zhuanlan.zhihu.com/p/65673502

## RRT

RRT(Rapidly-Exploring Random Trees) 快速随机扩展树,是一种单一查询路径规划算法，原理图如下

![](https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/20210316233745.png)

首先,在构型空间内随机(一般使用均匀分布)生成一个节点 q_rand，然后在已知的路径中找到和 q_rand 距离最短的节点 q_nearest，在线段 q 和 q_rand 之间找一个 q_new，是的 q 和 q_new 之间的距离为 step_size，最后检测 q_new 是否碰到障碍物，如果碰到则舍弃，继续选择下一个 q_new。重复上述过程,直到路径上最后一个节点距离目标位置在一定范围内,则找到了我们最终的路径.

一个简单的实现 demo 伪代码：

```
1. 设置起始点和目标点、障碍物列表
2. 调用 RRT 算法
	1.1 生成一个随机位置 q_rand
	1.2 找到和新生成的随机节点 q_rand 距离最近的节点 q_nearest
	1.3 利用反正切计算角度 theta = atan2(q_rand.y - q_nearest.y, q_rand.x - q_nearest.x)
	1.4 利用角度和步长计算新坐标 q_new(q_nearest.x + step_size * cos(theta), q_nearest.y + step_size * sin(theta))
	1.5 把新节点 q_new 的父节点设置为 q_nearest
	1.6 如果 CollisionCheck(q_new) == true 舍弃 q_new，返回步骤 1 重新选择下一个随机位置
	1.7 如果新节点到目标节点的距离 sqrt(q_new, goal) < step_size 则跳出循环
3. 根据父节点的指针反向画出规划的路径
```

注意：

- 在每次选择生长方向时，有一定的概率会向着目标点延伸，也有一定的概率会随机在地图内选择一个方向延伸一段距离。
- 随机采样的概率过大，RRT 树的分支也就越多，会导致生长缺乏方向性，是一种“碰运气”式的搜索。随机采样的概率过小，RRT 产生分支的太少，会导致很难绕过障碍物找到目标点。
- 步长的设置显然也会影响树的形状。当步长太大时，可能由于太过笨拙而无法成功绕过障碍物；当步长过小时，生长的速度显然会有所减慢（因为同样的距离要生长更多次），一般来说，空间越复杂，步长越小。

参考博客：

- https://zhuanlan.zhihu.com/p/195664738
- https://zhuanlan.zhihu.com/p/66047152






> {{ site.prompt }}



![](https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/dlonng_qrcode.jpg#pic_center)